* Emacs Literate Config
:PROPERTIES:
:ID: emacs-config-root
:END:

The pattern due to limiations using :var with quoted strings
is to return a string using format + concat (if needed),
:results value with escaped quoted strings. This enables the
use of '<<()>>' consistently for accessing variables. Consuming
code blocks will will require :noweb yes. :var is not used
at this time. The is enables a consitent approach for quoted
and non-quoted strings. This is the only way I could figure
out how to do this so that the approach was the same for quoted
and non-quoted strings.
   
* Environment
:PROPERTIES:
:ID: env-setup
:END:

Defines external environment variables and configurations used across modules.
Manually modify the `active-env` block below to switch between prod/dev environments.

Options emacs-prod | emacs-dev
#+NAME: target-env
#+BEGIN_SRC emacs-lisp :results value

  (format "\"%s\"" "emacs-prod")
#+END_SRC

#+RESULTS: target-env
: "emacs-prod"

Set target os.

Options archlinux | windows
#+NAME: target-os
#+BEGIN_SRC emacs-lisp :results value
  (format "\"%s\"" "archlinux")  
#+END_SRC

#+RESULTS: target-os
: "archlinux"

Variable definitions for those variables that can shared across all
modules and enviroments. These should be used judiciously.
All other variable definitions should be within their respective code blocks.
#+NAME: emacs-common-dir
#+BEGIN_SRC emacs-lisp :results value
  (format "\"%s\"" "~/.config/emacs-common")
#+END_SRC

#+RESULTS: emacs-common-dir
: "~/.config/emacs-common"

Set evnrionment variables.
#+NAME: env-vars
#+BEGIN_SRC emacs-lisp :noweb yes  :tangle ./modules/env.el
  (setq my/env <<target-env()>>)
  (setq server-name <<target-env()>>) 
#+END_SRC

#+RESULTS: env-vars
: emacs-prod

Starts emacs in server mode.
#+NAME: run-as-server
#+BEGIN_SRC emacs-lisp  :eval never :tangle ./modules/env.el
  (require 'server)
  (unless (server-running-p)
     (server-start))
#+END_SRC

Turn off yes/no prompt for evaluating org buffer.
#+NAME: confirm-babel-evaluate
#+BEGIN_SRC emacs-lisp  :eval never :tangle ./modules/env.el
  ;; Turn of eval protection
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

* Core
:PROPERTIES:
:ID: core
:END:

Core (native) emacs behavior configurtation. These setting should be the same across any of my hardware / os
environments (e.g. laptop, desktop, pi).

#+NAME: core
#+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/core.el
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-message t)
  (setq ring-bell-function 'ignore)
  (setq make-backup-files nil)

  ;; Initialize package system
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                            ("org" . "https://orgmode.org/elpa/")
                            ("elpa" . "https://elpa.gnu.org/packages/")))
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))

  ;; Ensure use-package is available
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)

  ;; Auto update packages
  (use-package auto-package-update
    :custom
    (auto-package-update-interval 7)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe)
    (auto-package-update-at-time "09:00"))

  ;; Clean up configuration file locations
  (use-package no-littering)

  ;; Ensure auto-save files go into no-littering's designated auto-save dir
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

  ;; Make ESC quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC

* Core-Extensions
:PROPERTIES:
:ID: core-extensions
:END:

Core extenstions to native emacs behavior. Ideally these will be the same across all environments.

#+NAME: core-extensions
#+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/core-extensions.el
  ;; Enable which-key for keybinding discovery
  (use-package which-key
    :defer 0
    :diminish
    :config
    (which-key-mode))

  ;; Completion and search system
  (use-package ivy
    :diminish
    :bind (("C-s" . swiper)
           :map ivy-minibuffer-map
           ("TAB" . ivy-alt-done)
           ("C-l" . ivy-alt-done)
           ("C-j" . ivy-next-line)
           ("C-k" . ivy-previous-line)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-previous-line)
           ("C-l" . ivy-done)
           ("C-d" . ivy-switch-buffer-kill)
           :map ivy-reverse-i-search-map
           ("C-k" . ivy-previous-line)
           ("C-d" . ivy-reverse-i-search-kill))
    :config
    (ivy-mode 1))

  (use-package counsel
    :bind (("C-M-j" . counsel-switch-buffer)
           :map minibuffer-local-map
           ("C-r" . counsel-minibuffer-history))
    :custom
    (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
    :config
    (counsel-mode 1))

  (use-package ivy-rich
    :after counsel
    :init
    (ivy-rich-mode 1))

  ;; Use to prioritize command history based on usage.
  (use-package ivy-prescient
  :after counsel
  :custom
  (ivy-prescient-enable-filtering nil)
  :config
  ;; Uncomment the following line to have sorting remembered across sessions!
  ;(prescient-persist-mode 1)
  (ivy-prescient-mode 1))

  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))
#+END_SRC

* UI
:PROPERTIES:
:ID: ui-config
:END:

UI configuration. Use the for frame / window decorations.

#+NAME: ui-config
#+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/ui.el
     ;; Font sizing defaults for UI scaling (override per-host if needed)
     (defvar my/default-font-size 100)
     (defvar my/default-variable-font-size 100)

     ;; Frame transparency defaults
     (defvar my/frame-transparency '(90 . 90))

     ;; Disable unnecessary UI elements
     (scroll-bar-mode -1)
     (tool-bar-mode -1)
     (tooltip-mode -1)
     (menu-bar-mode -1)
     (set-fringe-mode 10)

     ;; Set up the visible bell
     (setq visible-bell t)

     ;; Show column and line numbers
     (column-number-mode)
     (global-display-line-numbers-mode t)

     ;; Set frame font and theme
     (set-face-attribute 'default nil :font "JetBrains Mono" :height my/default-font-size)
     (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height my/default-font-size)
     (set-face-attribute 'variable-pitch nil :font "Cantarell" :height my/default-variable-font-size :weight 'regular)

     ;; Apply frame transparency
     (set-frame-parameter (selected-frame) 'alpha my/frame-transparency)
     (add-to-list 'default-frame-alist `(alpha . ,my/frame-transparency))

     ;; Icons and modeline
     (use-package all-the-icons)

     (use-package doom-themes
     :init (load-theme 'doom-palenight t))

     (use-package doom-modeline
       :init (doom-modeline-mode 1)
       :custom ((doom-modeline-height 15)))

     ;; Shows window numbers to select to change window
     (use-package ace-window
     :ensure t
     :bind (("M-o" . ace-window)))

     ;; Focus follows mouse
   (setq mouse-autoselect-window t)

    ;; Setup window borders like wtm
   (window-divider-mode 1)
   (setq window-divider-default-places t)
   (setq window-divider-default-bottom-width 1)
   (setq window-divider-default-right-width 1)

   ;; Set all borders to orange
  (set-face-attribute 'window-divider nil :foreground "orange")
  (set-face-attribute 'vertical-border nil :foreground "orange")

  ;; Mode line borders - also orange
  (set-face-attribute 'mode-line nil
                    :background "#4c566a"
                    :foreground "#eceff4"
                    :box '(:line-width 1 :color "orange"))

  (set-face-attribute 'mode-line-inactive nil
                    :background "#2e3440"
                    :foreground "#88909f"
                    :box '(:line-width 1 :color "orange"))

;;  Window shading - active window much darker
  (defvar my-active-window-background "#000000")    ; Very dark for active
  (defvar my-inactive-window-background "#2a2a2a")  ; Lighter for inactive

  (defun my-apply-window-shading ()
  "Apply shading - active window darker, inactive lighter."
     (dolist (window (window-list))
       (with-current-buffer (window-buffer window)
         (face-remap-reset-base 'default)
         (if (eq window (selected-window))
             ;; Active window - much darker
             (face-remap-add-relative 'default :background my-active-window-background)
           ;; Inactive windows - lighter
           (face-remap-add-relative 'default :background my-inactive-window-background)))))

  ;; Apply shading on window changes
  (add-hook 'window-selection-change-functions 
          (lambda (&rest _) (my-apply-window-shading)))

  ;; Protect settings from being overridden
  (defun my-protect-window-settings (&rest _)
     (when window-divider-mode
       (setq window-divider-default-bottom-width 1)
       (setq window-divider-default-right-width 1))
     (set-face-attribute 'window-divider nil :foreground "orange")
     (set-face-attribute 'vertical-border nil :foreground "orange")
     (my-apply-window-shading))

  (advice-add 'load-theme :after #'my-protect-window-settings)

  ;; Initialize everything
  (my-apply-window-shading)

  ;; End of Window Configuration
  (put 'erase-buffer 'disabled nil)    
 #+END_SRC

* Org
:PROPERTIES:
:ID: org-basic
:END:

Dedicated section for Org due to its scope of potential use and integration with emacs native.

Random notes, commands, quotes, etc. file.
#+NAME: random-notes-dir
#+BEGIN_SRC emacs-lisp :results value
  (format "\"%s\"" "~/Documents/stuff/random_notes.org")
#+END_SRC

#+RESULTS: random-notes-dir
: "~/Documents/stuff/random_notes.org"

Random notes function.
#+BEGIN_SRC emacs-lisp :eval never :noweb yes :tangle ./modules/org.el
 (use-package org
        :defer t )
  
  (setq my/random-notes-file <<random-notes-dir()>>)

    ;; Org Capture Template
    (setq org-capture-templates
          '(("r" "Random quick note"
             entry
             (file+headline my/random-notes-file "Inbox")
             "* %U %?\n  :tags: %^{Tags}\n"
             :empty-lines 1)))
    (global-set-key (kbd "C-c r") 'org-capture)
 #+END_SRC

 Enable python code blocks in babel.
#+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/org.el
 (org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)))
 #+END_SRC
 
* Email
:PROPERTIES:
:ID: email
:END:

Dedicated section for email due to its scope of potential use and integration with emacs native.

#+NAME: yahoo-email-dir
#+BEGIN_SRC emacs-lisp :results value
  (format "\"%s\"" "~/Maildir/yahoo")
#+END_SRC

#+RESULTS: yahoo-email-dir
: "~/Maildir/yahoo"

#+NAME: yahoo-email-address
#+BEGIN_SRC emacs-lisp :results value
  (format "\"%s\"" "mkburns61@yahoo.com")    
#+END_SRC

#+RESULTS: yahoo-email-address
: "mkburns61@yahoo.com"

#+NAME: yahoo-email-fullname
#+BEGIN_SRC emacs-lisp :results value
  (format "\"%s\"" "Mike Burns")    
#+END_SRC

#+RESULTS: yahoo-email-fullname
: "Mike Burns"

Big brother contacts database location.
#+NAME: bbdb-dir
#+BEGIN_SRC emacs-lisp :noweb yes :results value
  (format "\"%s\"" (concat <<emacs-common-dir()>>"/bbdb"))
#+END_SRC

#+RESULTS: bbdb-dir
: "~/.config/emacs-common/bbdb"


#+BEGIN_SRC emacs-lisp :eval never :noweb yes :tangle ./modules/email.el

    (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
    (require 'mu4e)

    (setq mu4e-maildir <<yahoo-email-dir()>>) ;; or wherever your Maildir lives
    (require 'mu4e)

    (setq user-mail-address <<yahoo-email-address()>>)
    (setq user-full-name <<yahoo-email-fullname()>>)

    (setq send-mail-function 'sendmail-send-it
          message-send-mail-function 'sendmail-send-it
          sendmail-program "/usr/bin/msmtp"
          mail-specify-envelope-from t
          mail-envelope-from 'header)

    (defun my/run-mbsync ()
      "Run mbsync to sync mail."
      (start-process-shell-command "mbsync" "*mbsync*" "mbsync -a"))

    ;; Run every 5 minutes (adjust as needed)
    (run-at-time "5 min" 300 #'my/run-mbsync)

    (setq mu4e-update-interval 300)  ;; 5 minutes

    ;; Setup image preview
    (setq mu4e-view-show-images t)
    (setq mu4e-view-use-gnus t) 
    (setq mu4e-view-image-max-width 800)
    (setq mu4e-view-show-addresses 't)

    (setq shr-inhibit-images nil)
    (setq gnus-inhibit-images nil)

    (defun my-mu4e-view-inline-images ()
      "Show images automatically in mu4e."
      (when (fboundp 'shr-put-image)
        (setq mu4e-view-show-images t)))

    (setq url-privacy-level 'low)

    (defun my/mu4e-view-message-no-focus ()
      "View the current message in another window without changing focus."
      (interactive)
      (let ((msg (mu4e-message-at-point)))
        (when msg
          (save-selected-window
            (mu4e-view msg)))))

    (with-eval-after-load 'mu4e
      (define-key mu4e-headers-mode-map (kbd "V") #'my/mu4e-view-message-no-focus))

    ;; Open email in a dedicated frame for better workflow.
    (defun my/mu4e-open-in-dedicated-frame ()
      "Open mu4e in a dedicated frame named 'mu4e'."
      (interactive)
      (let ((bufname "*mu4e*"))
        (if (get-buffer bufname)
            ;; If buffer already exists, raise the frame or switch to it
            (progn
              (select-frame-set-input-focus
               (window-frame (get-buffer-window bufname))))
          ;; Else create new frame and launch mu4e
  	(let* ((frame (make-frame '((name . "mu4e")
                                      (width . 100)
                                      (height . 40)))))
            (select-frame-set-input-focus frame)
            (with-selected-frame frame
              (mu4e)
              (set-window-dedicated-p (selected-window) t))))))

    ;; Use bbdb for email contacts configuration.
    (use-package bbdb
          :defer t )

    (setq bbdb-file <<bbdb-dir()>>)
    (require 'bbdb)
    (require 'bbdb-com)
    (bbdb-initialize 'mu4e 'message)

    (setq mu4e-use-bbdb t)

    (bbdb-mua-auto-update-init 'mu4e)

    (setq message-completion-alist
        '((message-to . bbdb-complete-mail)
          (message-cc . bbdb-complete-mail)
          (message-bcc . bbdb-complete-mail)))

    (define-key message-mode-map (kbd "TAB") 'bbdb-complete-mail)
 #+END_SRC

* Dev Environment
:PROPERTIES:
:ID: dev-env
:END:

My dev envrionments.

#+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/dev.el
  (use-package typescript-mode
    :mode "\\.ts\\'")

  (use-package python-mode
    :hook (python-mode . eglot-ensure))

  (use-package pyvenv
    :config (pyvenv-mode 1))

  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    (when (file-directory-p "~/Documents/Code")
      (setq projectile-project-search-path '("~/Documents/Code")))
    (setq projectile-switch-project-action #'projectile-dired))

  (use-package counsel-projectile
    :config (counsel-projectile-mode))

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

  (use-package request
  :ensure t)

  (require 'request)
  (require 'json)

  ;; ChatGPT AI integration.
  (setq chatgpt-shell-save-session t)
  (global-set-key (kbd "C-c g") #'chatgpt-shell)

  (setq chatgpt-shell-openai-key "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")

  (setq chatgpt-shell-anthropic-key "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")

  (setq chatgpt-shell-google-key "AIzaSyDkF0ZNBH208yLG48x_iv6kDVk0pjo6g3E")
#+END_SRC

* System & OS Integration
:PROPERTIES:
:ID: system-os-env
:END:

System / OS integration that might change across hardware /OS's etc.

#+NAME: show-dotfiles
#+BEGIN_SRC emacs-lisp :results value :noweb yes
    (cond
     ((string= <<target-os()>> "archlinux")
      "(setq dired-listing-switches \"-alh --group-directories-first\")")
     ((string= <<target-os()>> "macos")
      "(setq dired-listing-switches \"-alh\")")
     (t "Unknown OS"))
#+END_SRC

#+RESULTS: show-dotfiles
: (setq dired-listing-switches "-alh --group-directories-first")

Dired configurations.
#+BEGIN_SRC emacs-lisp :eval never :noweb yes :tangle ./modules/system-os.el
  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump)))

  <<show-dotfiles()>>

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))

  ;; Launch apps based on content.
  (use-package dired-open
    :config
    (setq dired-open-extensions
  	'(("png" . "feh")
  	  ("jpg" . "feh")
  	  ("pdf" . "zathura")
  	  ("mp4" . "mpv")
  	  ("mkv" . "mpv")
  	  ("html" . "floorp"))))

  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode))

  ;; Must have dired extensions
  (use-package peep-dired
    :ensure t
    :bind (:map dired-mode-map
                ("P" . peep-dired))
    :hook (peep-dired-mode . (lambda () (setq-local image-dired-display-image-buffer 'other))))

  (use-package dired-subtree
    :ensure t
    :bind (:map dired-mode-map
                ("<tab>" . dired-subtree-toggle)))
#+END_SRC

Terminal
#+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/system-os.el
  (use-package vterm
    :commands vterm
    :bind ("C-c v" . vterm)
    :config
    (setq vterm-shell "/usr/bin/fish")
    (setq vterm-max-scrollback 10000))
#+END_SRC

* My Functions
:PROPERTIES:
:ID: my-functions
:END:

This section is dedicated to my functions. These will eventually be generated based on target environment.

Niri literate config.kdl tangle and deploy. This function will evaluate
and tangle the niri config.kdl and deploy it into the correct niri
directory, with included rollback capability.

#+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/my-functions.el
  (defun niri-babel-build-and-deploy ()
    "Execute all necessary blocks (except kdl), tangle, and deploy to ~/.config/niri/config.kdl"
    (interactive)
    (let* ((org-file "~/projects/niri_babel_config/niri_config.org")
           (output-dir "~/projects/niri_babel_config/")
           (output-file (expand-file-name "config.kdl" output-dir))
           (target-file "~/.config/niri/config.kdl"))
      (with-current-buffer (find-file-noselect org-file)
        ;; Execute only non-KDL blocks
        (org-babel-map-src-blocks org-file
          (let* ((info (org-babel-get-src-block-info))
                 (lang (nth 0 info)))
            (unless (string= lang "kdl")
              (org-babel-execute-src-block))))
        ;; Tangle everything
        (org-babel-tangle)
        ;; Copy the output
        (when (file-exists-p output-file)
          (copy-file output-file target-file t)
          (message "Tangled and copied config.kdl to %s" target-file)))))
 #+END_SRC

This is a prototype / test / learning function. To use it add this function to
emacsclient startup and it will display thumbnails for the screenshots directory,
allow you to select a single thumbnail, copy it to the clipboard and exit.
This is used in niri with a similar function using feh. The goal was to see
how close emacs could reproduce the feh functionality. The results are pretty
good and this is currently wired as a keybind in niri as is feh.

 #+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/my-functions.el
   (require 'image-dired)

   (defun my/image-dired-copy-and-exit ()
     "Copy image under point in image-dired and exit Emacsclient."
     (interactive)
     (let* ((file (image-dired-original-file-name))
            (copy-prog (or (executable-find "wl-copy")
                           (executable-find "xclip"))))
       (unless copy-prog
         (error "No clipboard utility (wl-copy or xclip) found"))
       (unless (and file (file-exists-p file))
         (error "No image found under cursor"))
       (with-temp-buffer
         (insert-file-contents-literally file)
         (call-process-region
          (point-min) (point-max)
          copy-prog nil nil nil "-t" "image/png"))
       (save-buffers-kill-terminal)))

   (with-eval-after-load 'image-dired
     ;; `m` to copy and exit
     (define-key image-dired-thumbnail-mode-map (kbd "m") #'my/image-dired-copy-and-exit)
     ;; `q` to just quit
     (define-key image-dired-thumbnail-mode-map (kbd "q")
       (lambda ()
         (interactive)
         (save-buffers-kill-terminal))))

   (defun my/image-picker-thumbnail-mode ()
     "Launch thumbnail-only image picker. Press `m` to copy & exit."
     (interactive)
     (let ((dir "~/Pictures/screenshots/"))
       ;; Save current window configuration, run image-dired
       (image-dired dir)
       ;; Force delete all windows except the one showing *image-dired*
       (let ((image-buffer "*image-dired*"))
         (dolist (win (window-list))
           (unless (eq (window-buffer win) (get-buffer image-buffer))
             (delete-window win)))
         (select-window (get-buffer-window image-buffer)))))
 #+END_SRC

Show the server name that this emacsclient is connected to.
 #+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/my-functions.el
    ;; Show the server name that this emacsclient is connected to.
    (defun show-current-server-name ()
      "Display the name of the Emacs server this client is connected to."
      (interactive)
      (message "Connected to Emacs server: %s" server-name))

    ;; Then bind it in the startup hook
    (add-hook 'emacs-startup-hook
              (lambda ()
                (global-set-key (kbd "<f12>") #'show-current-server-name)))
 #+END_SRC

List niri active windows.
 #+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/my-functions.el
   ;; Output niri-windows to new buffer
   (defun niri-windows ()
     "Show Niri windows in a new buffer."
     (interactive)
     (let ((buf (get-buffer-create "*niri-windows*")))
       (with-current-buffer buf
         (read-only-mode -1)
         (erase-buffer)
         (call-process "~/projects/niri_toolkit/niri-windows.py" nil buf)
         (goto-char (point-min))
         (read-only-mode 1))
       (pop-to-buffer buf)))
 #+END_SRC

Connect to niri IPC and display events in a buffer.
  #+BEGIN_SRC emacs-lisp :eval never :tangle ./modules/my-functions.el
   ;;Output niri-event-stream via IPC to new buffer
   (defun niri-event-stream ()
     "Show the Niri event stream in a new buffer."
     (interactive)
     (let ((buf (get-buffer-create "*Niri Event Stream*")))
       (apply 'make-comint-in-buffer
              "Niri Event Stream"
              buf
              (expand-file-name "~/projects/niri_toolkit/niri-tail-event-stream.py")
              nil)
       (pop-to-buffer buf)))
 #+END_SRC

* Table of Contents / Manifest
:PROPERTIES:
:ID: toc-manifest
:END:

A high-level view of config modules.

| Section                 | ID              | Tangle Path                  | Notes                   |
|-------------------------+-----------------+------------------------------+-------------------------|
| Environment             | env-setup       | ./modules/env.el             | Shared values           |
| Core                    | core            | ./modules/core.el            | Emacs core              |
| Core-Extensions         | core-extensions | ./modules/core-extensions.el | Extension to emacs core |
| UI                      | ui-config       | ./modules/ui.el              | UI (Theme, font, etc.)  |
| Org                     | org-basic       | ./modules/org.el             | Org                     |
| Dev                     | dev-env         | ./modules/dev.el             | Dev tooling             |
| System & OS Integration | system-os-env   | ./modules/system-os.el       | System & OS Utilities   |
| Email                   | email           | ./modules/email.el           | Email                   |
| My Functions            | my-functions    | ./modules/my-functions.el    | My custom functions     |
